
1. Использование RAII в коде может быть при работе с файлами. Например, если открывыть файл для чтения или записи, можно использовать класс, который открывает файл в конструкторе и закрывает его в деструкторе. Это позволяет избежать утечек ресурсов и гарантирует, что файл будет закрыт правильно даже в случае исключения.

2. При реализации глубокого копирования я создавал новый объект и копировал все его поля, включая динамически выделенные ресурсы, чтобы у каждого объекта были свои собственные копии ресурсов. При поверхностном копировании я просто копировал указатели на ресурсы, что может привести к проблемам при выполнении операций на объектах. Для реализации глубокого копирования мне пришлось следить за правильным выделением и освобождением памяти для каждого ресурса.

3. В коде создал базовый класс "Фигура" с виртуальной функцией "расчет площади". Затем создал два производных класса, "Прямоугольник" и "Круг", которые переопределили эту функцию. 

При вызове функции "расчет площади" для объектов типа "Фигура", система использует таблицу виртуальных функций (vtable) для определения, какая именно функция должна быть вызвана в конкретном случае - "расчет площади" для прямоугольника или для круга.

Таким образом, использование виртуальных функций позволяет достичь полиморфизма - возможность вызывать одну и ту же функцию для разных типов объектов и получать ожидаемый результат в зависимости от типа объекта.

4. При реализации паттерна Singleton мне пришлось обеспечить, чтобы только один экземпляр класса существовал в системе. Для этого я использовал статический метод, который возвращал указатель на единственный экземпляр класса и проверял его наличие при каждом обращении. 

5. Правило пяти требует определения и реализации конструктора перемещения и оператора перемещения в дополнение к конструктору копирования и оператору присваивания. В моем коде, при работе с динамической памятью, я использовал перемещение объектов для улучшения производительности и экономии памяти.

6. std::vector обеспечивает быстрый доступ к элементам по индексу и хранение элементов в непрерывной области памяти, что обеспечивает эффективное кэширование. std::list обеспечивает быстрые вставку и удаление элементов в середине контейнера, но доступ к элементам по индексу может быть медленным из-за необходимости последовательного прохода по элементам. Я использовал std::vector для хранения большого количества элементов, если необходимы операции по индексу, и std::list для частых операций вставки и удаления элементов из середины контейнера.

7.  Когда нужно было преобразовать переменную типа double в int для выполнения математических операций. Я выбрал статическое приведение типов (static_cast), так как заранее знал, что значения переменной double не будут потеряны при приведении к целочисленному типу int.

8.  Это концепция, которая позволяет более эффективно управлять ресурсами при передаче объектов в функции. Например, использование std::move для перемещения ресурсов из одного объекта в другой без копирования. Это помогает избежать лишних операций копирования и улучшает производительность приложения.

9. Для создания собственных исключений, я создавал собственный класс исключений, который наследовался от std::exception. Это помогло улучшить обработку ошибок в программе, так как  можно точно указать причину и тип ошибки, что облегчит отладку и исправление проблем.

10. 

11. const используется для указания, что значение переменной не может быть изменено, в то время как constexpr используется для определения констант во время компиляции. Я использовал const для сохранения неизменных значений переменных, а constexpr не использовал.

12. Умные указатели представляют собой удобный инструмент для управления динамической памятью. std::unique_ptr предоставляет единственное владение ресурсом, std::shared_ptr позволяет разделять ресурсы между несколькими указателями, а std::weak_ptr позволяет избежать циклических зависимостей в указателях.

13. Использовал шаблоны для создания обобщенных функций и классов, которые могли работать с различными типами данных. Проблемы возникали при обработке типов данных, их удалось решить, определяя специализации шаблонов для конкретных типов.

14. std::enable_if используется для условного выбора шаблонов в зависимости от определенных условий. Использовал его для реализаций для разных типов данных, что позволяло оптимизировать использование шаблонов.

15. При управлении динамической памятью с помощью кучи старался минимизировать утечки памяти, освобождая память после использования и избегая лишних выделений. Оптимизировал использование памяти путем использования умных указателей.
